#! Arithmetic operations.

import "lib/core/ops.tao"

class Zero =
    => zero : Self

def zero A < Zero : A = A.zero

member Nat of Zero =
    => zero = 0

class One =
    => one : Self

def one A < One : A = A.one

member Nat of One =
    => one = 1

class Num < Zero + One + Add Self + Mul Self

# A generic vector type

class VectorData A =
    => Data
    => splat : A -> Self.Data
    => map2 : Self.Data -> Self.Data -> (A -> A -> A) -> Self.Data

data Vector A, N < VectorData A = N.Data

for A, N member Vector A N of Add (Vector A N) where
    N < VectorData A,
    A < Add A with { Output = A },
=
    => Output = Self
    => add = fn Vector x, Vector y => Vector N.map2(x, y, fn x, y => x + y)

data N2
for A member N2 of VectorData A =
    => Data = { x : A, y : A }
    => splat = fn e => { x : e, y : e }
    => map2 = fn xs, ys, f => { x : f(xs.x, ys.x), y : f(xs.y, ys.y) }

data N3
for A member N3 of VectorData A =
    => Data = { x : A, y : A, z : A }
    => splat = fn e => { x : e, y : e, z : e }
    => map2 = fn xs, ys, f => { x : f(xs.x, ys.x), y : f(xs.y, ys.y), z : f(xs.z, ys.z) }

fn splat A, N < VectorData A : A -> Vector A N =
    e => Vector N.splat(e)

for A < Zero, N < VectorData A member Vector A N of Zero =
    => zero = splat(A.zero)
