#! Arithmetic operations.

import "lib/core/ops.tao"

class Zero =
    => zero : Self

def zero A < Zero : A = A.zero

member Nat of Zero =
    => zero = 0

class One =
    => one : Self

def one A < One : A = A.one

member Nat of One =
    => one = 1

class Num where
    Self < Zero + One,
    Self < Add Self with { Output = Self },
    Self < Mul Self with { Output = Self },

for A member A of Num where
    A < Zero + One,
    A < Add A with { Output = A },
    A < Mul A with { Output = A },

# A generic vector type

class VectorData A =
    => Data
    => splat : A -> Self.Data
    => map : Self.Data -> (A -> A) -> Self.Data
    => map2 : Self.Data -> Self.Data -> (A -> A -> A) -> Self.Data

data Vector A, N < VectorData A = N.Data

for A, N member Vector A N of Add (Vector A N) where
    N < VectorData A,
    A < Add A with { Output = A },
=
    => Output = Self
    => add = fn Vector xs, Vector ys => Vector N.map2(xs, ys, fn x, y => x + y)

for A, B, N member Vector A N of Add B where
    N < VectorData A,
    A < Add B with { Output = A },
=
    => Output = Self
    => add = fn Vector xs, y => Vector N.map(xs, fn x => x + y)

for A, N member Vector A N of Mul (Vector A N) where
    N < VectorData A,
    A < Mul A with { Output = A },
=
    => Output = Self
    => mul = fn Vector xs, Vector ys => Vector N.map2(xs, ys, fn x, y => x * y)

data N2
for A member N2 of VectorData A =
    => Data = { x : A, y : A }
    => splat = fn e => { x : e, y : e }
    => map = fn xs, f => { x : f(xs.x), y : f(xs.y) }
    => map2 = fn xs, ys, f => { x : f(xs.x, ys.x), y : f(xs.y, ys.y) }

data N3
for A member N3 of VectorData A =
    => Data = { x : A, y : A, z : A }
    => splat = fn e => { x : e, y : e, z : e }
    => map = fn xs, f => { x : f(xs.x), y : f(xs.y), z : f(xs.z) }
    => map2 = fn xs, ys, f => { x : f(xs.x, ys.x), y : f(xs.y, ys.y), z : f(xs.z, ys.z) }

fn splat A, N < VectorData A : A -> Vector A N =
    e => Vector N.splat(e)

for A < Zero, N < VectorData A member Vector A N of Zero =
    => zero = splat(A.zero)

for A < One, N < VectorData A member Vector A N of One =
    => one = splat(A.one)

fn mul_add A < Num : A -> A -> A -> A =
    x, y, z => x * y + z

def mul_add_demo : Vector Nat N3 = mul_add(zero, one, one)
