class Any =
    type_name : Str

for A member A of Any =
    type_name =
        # No way to specify type hints for intrinsics yet so...
        # ...we create an empty list of the target type...
        let xs : [A] = [] in
        # ...then pass the list to the intrinsic, which uwraps the list and extracts the type,
        # generates its name
        @type_name(xs)

def type_name A < Any =
    \ x : A => A.type_name

class Default =
    default : Self

member Nat of Default =
    default = 0

for A member Maybe A of Default =
    default = None

for A < Default, B < Default member (A, B) of Default =
    default = (A.default, B.default)

def zero = Nat.default

data Maybe A =
    | Just A
    \ None

class Add =
    add : Self -> Self -> Self

class Show =
    show : Self -> Str

member Nat of Show =
    show = fn _ => "a nat"

for A < Show, B < Show member (A, B) of Show =
    show = fn (a, b) => "(" ++ A.show(a) ++ ", " ++ B.show(b) ++ ")"

data Result A, E =
	| Ok A
	\ Err E

def len A : [A] -> Nat =
	| [] => 0
	\ [_ .. tail] => 1 + tail:len

def nth A : Nat -> [A] -> Maybe A =
    | 0, [x ..] => Just x
    | n + 1, [_ .. tail] => tail:nth(n)
    \ _, _ => None

def fold A, B : A -> (A -> B -> A) -> [B] -> A =
	| init, _, [] => init
	\ init, f, [x .. tail] => fold(f(init, x), f, tail)

def sum : [Nat] -> Nat = fold(0, fn x, y => x + y)

# TODO: Remove when libs are supported
$[main] def main = <Maybe Nat>.default#[1, 2, 3, 4]:sum

type Str = [Char]
