# Without effect handling

fn map A, B : (A -> B) -> [A] -> [B] is
    | _, [] => []
    \ f, [a .. as] => [a:f .. as:map(f)]

# With effect handling

fn map A, B, e : (A -> e ~ B) -> [A] -> e ~ [B] is
    | _, [] => []
    \ f, [a .. as] => [a:f! .. as:map(f)]

## General rule:
effect foo A, B, C is A, B => C
## ...implicitly generates...
fn foo A, B, C : A -> B -> foo(A, B, C) ~ C is
    # `~ effect` syntax in intrinsics allows mentioning an effect by name
    # Also permitted: `: type` for types
    a, b => @suspend(~ foo(A, B, C), a, b)

# Effects, always take the form [<ty>] => <ty>
effect print is Str => ()
effect input is () => Str

# Implicitly generated by effects above
fn print : Str -> print ~ () is
    \ s => @suspend(~ print, s)
fn input : input ~ Str is
    @suspend(~ input, ())

# Composed effects
effect io = print + input

fn for_each A, e : (A -> e ~ ()) -> [A] -> e ~ () is
    | _, [] => ()
    \ f, [a .. as] => a:f!; as:for_each(f)

effect yield A is A => ()
# Implicitly generated by effect above
fn yield A : A -> yield(A) ~ () is
    \ x => @suspend(~ yield(A), x)

# Example usage of effects
# Atomic pattern is (<expr>;<expr>;<expr>) with optional trailing semicolon
fn main : io ~ () is (
    let name = input!;
    print("Hello, " ++ name)!;
    print("How are you?")!;
    handle yield(Nat) in n => print(n:show)! on
        [1, 2, 3]
            :for_each(yield);
)

# Effect handler for IO
fn handle_io A : print + input ~ A -> @ -> (A, @) is
    \ eff, uni =>
        with uni
            handle print in uni, s => (@print(s, uni), ())
            handle input in uni, () => @input(uni)
        on
            eff

# Actual program start, just deals in universe mapping
fn _start : @ -> ((), @) is
    handle_io(main)

# Async/await
data Poll A =
    | Ready A
    \ Pending

class Future =
    => Output
    => poll : Self -> Reactor -> (Reactor, Poll(Self.Output))

effect async is
    => await F < Future is F => F.Output

fn async_main : async ~ () is (
    print("Waiting for 10 seconds...")!;
    timer(10:seconds)!;
    print("Hello, world!")!;
)

data Reactor = {
    uni: @,
    ...
}

fn main : @ -> @ is uni =>
    with Reactor { uni }
        handle async in
            => await F < Future is reactor, fut => match F.poll(fut, reactor) in
                | (reactor, Ready x) => (reactor, x)
                \ (reactor, Pending) => ...
    on
        async_main


fn async_main : async ~ () is
    ...

data Rt = {
    waiting: Map(Token, Task)
}

fn process_event : Event -> @ -> Rt -> (Rt, @) is
    ...

fn process_events : Rt -> @ -> @ is rt, uni =>
    match @wait_event(uni) in
        | (Shutdown, uni) => (rt, uni)
        \ (event, uni) =>
            let (rt, uni) = rt:process_event(event, uni) in
            process_events(rt, uni)

fn main : @ -> @ is uni =>
    let rt = default in
    let fut = async_main in
    process_events(rt, uni)










fn main : @ -> (@, ()) is
    let eff = ... in
    fix(
        fn rec, uni, eff => match @pull(~print, eff) in
            | Next (waiting, f) =>
                let (uni, r) = uni:f in
                rec(uni, @push(~print, waiting, r))
            \ Break () => (uni, ())
        uni,
        eff,
    )




























