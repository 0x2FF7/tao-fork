import "lib/std.tao"

class Stream =
    => Item
    => next : Self -> (Maybe Self.Item, Self)

for A member [A] of Stream =
    => Item = A
    => next = fn
        | [x .. xs] => (Just x, xs)
        \ [] => (None, [])

data Take S < Stream = {
    s: S,
    n: Nat,
}

for S < Stream member Take S of Stream =
    => Item = S.Item
    => next = fn
        | self ~ Take { s, n ~ 0 } => (None, self)
        \ Take { s, n ~ n + 1 } =>
            let (x, s) = S.next(s) in
            (x, Take { s, n })

def take S < Stream =
    \ n, s : S => Take { s, n }

def collect S < Stream = fn s => match S.next(s) in
    | (Just x, s) => [x .. s:collect]
    \ (None, _) => []

class Mappable =
    => Item
    => Output
    => map : (Self.Item -> Self.Item) -> Self -> Self.Output

for A member [A] of Mappable =
    => Item = A
    => Output = [A]
    => map = fn f, self => self:map(f)

def do_map A < Mappable =
    \ f, m => A.map(f, m)

$[main]
def main = [1, 2, 3, 4]:take(3):collect

class Foo =
    => Bar
    => foo : Self.Bar

member Nat of Foo =
    => Bar = Bool
    => foo = True

def foo_nat : Nat.Bar = Nat.foo

class Neg =
    => Output
    => neg : Self -> Self.Output

def neg A < Neg : A -> A.Output = A.neg

# $[main]
# def main = [
#         (4, "e"),
#         (2, "c"),
#         (0, "a"),
#         (3, "d"),
#         (1, "b"),
#     ]
#         :from_list
#         :contains(4)
#         :debug

# def main2 = do
#     let msg = input;
#     if msg = "exit" then do
#         print("Now exiting...");
#         print("Goodbye!");
#     else do
#         print("Hello, world!");
#         main2; # Loop
