import "../lib/main.tao"

## Mutations take a function that maps a value to another of the same type
## They don't output anything (unlike an effect such as 'get some user input')
effect mut A = (A -> A) => ()

## TODO: Have the compiler auto-generate this bit instead of
## forcing the effect user to deal with intrinsics.
fn mut A : (A -> A) -> mut A ~ () = f => do {
    @suspend(f)
}

## Apply a series of mutations to a value
fn apply A : mut A ~ () -> A -> A =
    m, x => let (_, x) = (m, x)
        handle mut A with f, x => ((), x -> f)
    in x

## A mutation that pushes an element to the end of a list
fn push A : A -> mut [A] ~ () =
    x => mut(fn xs => xs ++ [x])

## Example usage

def numbers = do {
    push(1)!;
    push(2)!;
    push(3)!;
    push(4)!;
}

## Debug-prints '[1, 2, 3, 4]' to the console
def main : io ~ () = []
    -> apply(numbers)
    -> debug
    -> print
