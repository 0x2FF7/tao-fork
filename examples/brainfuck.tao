import "../lib/main.tao"

data Instr =
    | Left
    | Right
    | Incr
    | Decr
    | Read
    | Write
    \ Loop [Instr]

fn parse =
    | ['<' .. s] => let (xs, s) = s->parse in ([Left .. xs], s)
    | ['>' .. s] => let (xs, s) = s->parse in ([Right .. xs], s)
    | ['+' .. s] => let (xs, s) = s->parse in ([Incr .. xs], s)
    | ['-' .. s] => let (xs, s) = s->parse in ([Decr .. xs], s)
    | [',' .. s] => let (xs, s) = s->parse in ([Read .. xs], s)
    | ['.' .. s] => let (xs, s) = s->parse in ([Write .. xs], s)
    | [']' .. s] => ([], s)
    | ['[' .. s] =>
        let (xs, s) = s->parse in
        let (tail, s) = s->parse in
        ([Loop xs] ++ tail, s)
    | [_ .. s] => s->parse
    \ [] => ([], "")

data State = {
    ptr: Nat,
    tape: [Nat],
    stdin: Str,
    stdout: Str,
}

member State of Default =
    => default = State {
        ptr: 0,
        tape: [0]->repeat(1000),
        stdin: "",
        stdout: "",
    }

fn exec : State -> Instr -> io ~ State =
    | state, Left => do
        state with {
            ptr: match state.ptr in
                | 0 => 9999
                \ l + 1 => l
        }
    end
    | state, Right => do
        state with {
            ptr: match state.ptr in
                | 9999 => 0
                \ l => l + 1
        }
    end
    | state, Incr => do
        state with {
            tape: state.tape->swap(state.ptr, fn
                | 255 => 0
                \ n => n + 1)
        }
    end
    | state, Decr => do
        state with {
            tape: state.tape->swap(state.ptr, fn
                | 0 => 255
                \ n + 1 => n)
        }
    end
    | state, Read => do
        print("Read not supported yet")!;
        state
    end
    | state, Write => match state.tape->nth(state.ptr) in
        # Newline
        | Just 10 => do
            print(state.stdout)!;
            state with { stdout: "" }
        end
        | Just n + 32 => match " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
            -> nth(n) in
            | Just c => do
                state with { stdout: state.stdout ++ [c] }
            end
            \ None => do state end
        \ _ => do state end
    \ state, Loop xs => match state.tape->nth(state.ptr) in
        | Just 0 => do state end
        | Just _ => do
            let state = exec_all(state, xs)!;
            exec(state, Loop xs)!
        end
        \ None => do state end

fn exec_all : State -> [Instr] -> io ~ State =
    | state, [] => do state end
    \ state, [x .. xs] => do
        let state = exec(state, x)!;
        exec_all(state, xs)!
    end

def main : io ~ () = do
    let (xs, _) = "
        [sierpinski.b -- display Sierpinski triangle
        (c) 2016 Daniel B. Cristofani
        http://brainfuck.org/]
        ++++++++[>+>++++<<-]>++>>+<[-[>>+<<-]+>>]>+[
            -<<<[
                ->[+[-]+>++>>>-<<]<[<]>>++++++[<<+++++>>-]+<<++.[-]<<
            ]>.>+[>>]>+
        ]
        [Shows an ASCII representation of the Sierpinski triangle
        (iteration 5).]
    "->parse;
    exec_all(default, xs)!;
end
