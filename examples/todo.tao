#(
	Multi-line comments look like this
)

# Anonymous product and sum types
type Person = { name :: Str, age :: Num }
type Animal = { dog | cat } # Fields without types implicitly have type `()`
# ...equivalent to...
type Animal = { dog :: () | cat :: () }
# Also possible in product types (although somewhat pointless)
type Empty = { these, are, unit, fields }

# Can be used in a `match`
def an_animal = match { dog } {
	# Unification of `{ dog }` and `{ cat }` produces `{ dog | cat }`.
	# However, unification of `{ dog }` and `{ dog: Num }` would produce a type mismatch error.
	| { dog } => { dog },
	| { cat } => { cat },
}

# Public qualifiers
pub data Maybe A =
	| Some A
	| None

pub data Result A, E =
	| Ok A
	| Err E

# Private definitions may have their types inferred
def five = 5

# Public definitions must always have fully explicit type annotations
pub def five :: Num = 5

# Recursive definitions may use contextual inference
def factorial = |x| if x = 0
	then 1
	else x * factorial(x - 1)

# Use statements import things into scope
# self, root, and parent are all keywords
use foo.bar # Implicitly becomes self.foo.bar

# Declare child modules (in other files). Modules are always files (cannot be defined inline)
mod foo

# Forms describe interfaces
form Sort A = {
	def sort :: [A] -> [A]
}

# Implementations describe the internals of a form
impl Quicksort A :: Sort A = {
	def sort = |xs| match xs:nth(xs:len / 2) {
		| None => xs
		| Some x => xs:filter(|e| e < x):sort ++ xs:filter(|e| e >= x):sort
	}
}

# Form implementations can be passed like values using the `impl` keyword.
# `impl Sort A` is not a type, it is form. `alg` is not a value, it is a form implementation.
pub def sort A :: impl Sort A -> [A] -> [A] =
	|alg, xs| alg.sort(xs)

pub def quicksort A :: [A] -> [A] = sort(impl Quicksort)






# Hmmm. Why not this?
pub data Sort A = {
	sort :: [A] -> [A]
}

def quicksort A :: Sort A = {
	sort: |xs| match xs:nth(xs:len / 2) {
		| None => xs
		| Some x => xs:filter(|e| e < x):quicksort.sort ++ xs:filter(|e| e >= x):quicksort.sort
	},
}
